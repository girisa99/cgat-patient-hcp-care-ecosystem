/**
 * Enhanced Module Registry System with Component/Service Tracking
 * 
 * This system maintains a registry of all modules and their configurations,
 * enabling real-time updates, validation, automatic registration, and RBAC tracking.
 */

import { ModuleConfig } from './moduleValidation';

export interface ComponentServiceInfo {
  name: string;
  type: 'component' | 'service' | 'hook';
  filePath: string;
  permissions: string[];
  isProtected: boolean;
  lastModified: string;
}

export interface RegisteredModule extends ModuleConfig {
  version: string;
  lastUpdated: string;
  dependencies: string[];
  status: 'active' | 'deprecated' | 'development';
  isAutoGenerated?: boolean;
  confidence?: number;
  description?: string;
  components?: ComponentServiceInfo[];
  services?: ComponentServiceInfo[];
  hooks?: ComponentServiceInfo[];
}

export interface AutoRegistrationConfig {
  enabled: boolean;
  confidenceThreshold: number;
  scanIntervalMs: number;
  autoGenerateCode: boolean;
  trackComponents: boolean;
  trackServices: boolean;
}

class ModuleRegistry {
  private modules: Map<string, RegisteredModule> = new Map();
  private componentIndex: Map<string, { moduleName: string; component: ComponentServiceInfo }> = new Map();
  private listeners: Set<(modules: RegisteredModule[]) => void> = new Set();
  private autoConfig: AutoRegistrationConfig = {
    enabled: false,
    confidenceThreshold: 0.8,
    scanIntervalMs: 30000,
    autoGenerateCode: true,
    trackComponents: true,
    trackServices: true
  };

  /**
   * Register a new module or update existing one
   */
  register(module: RegisteredModule) {
    console.log(`ðŸ“ Registering module: ${module.moduleName}`);
    
    const existing = this.modules.get(module.moduleName);
    if (existing) {
      console.log(`ðŸ”„ Updating existing module: ${module.moduleName}`);
    }

    const updatedModule = {
      ...module,
      lastUpdated: new Date().toISOString()
    };

    this.modules.set(module.moduleName, updatedModule);
    
    // Update component index
    this.updateComponentIndex(module.moduleName, updatedModule);

    this.notifyListeners();
  }

  /**
   * Add component/service to a module
   */
  addComponentToModule(moduleName: string, component: ComponentServiceInfo) {
    const module = this.modules.get(moduleName);
    if (!module) {
      console.warn(`Module ${moduleName} not found for component ${component.name}`);
      return;
    }

    const updatedModule = { ...module };
    
    switch (component.type) {
      case 'component':
        updatedModule.components = [...(updatedModule.components || []), component];
        break;
      case 'service':
        updatedModule.services = [...(updatedModule.services || []), component];
        break;
      case 'hook':
        updatedModule.hooks = [...(updatedModule.hooks || []), component];
        break;
    }

    updatedModule.lastUpdated = new Date().toISOString();
    this.modules.set(moduleName, updatedModule);
    
    // Update component index
    this.componentIndex.set(component.name, { moduleName, component });
    
    console.log(`ðŸ§© Added ${component.type} ${component.name} to module ${moduleName}`);
    this.notifyListeners();
  }

  /**
   * Get all components across modules for RBAC
   */
  getAllComponents(): { moduleName: string; component: ComponentServiceInfo }[] {
    return Array.from(this.componentIndex.values());
  }

  /**
   * Get components by permission
   */
  getComponentsByPermission(permission: string): { moduleName: string; component: ComponentServiceInfo }[] {
    return this.getAllComponents().filter(({ component }) => 
      component.permissions.includes(permission)
    );
  }

  /**
   * Get module components for RBAC display
   */
  getModuleComponentsForRBAC(moduleName: string): ComponentServiceInfo[] {
    const module = this.modules.get(moduleName);
    if (!module) return [];

    return [
      ...(module.components || []),
      ...(module.services || []),
      ...(module.hooks || [])
    ];
  }

  /**
   * Update component index for fast lookups
   */
  private updateComponentIndex(moduleName: string, module: RegisteredModule) {
    // Clear existing entries for this module
    Array.from(this.componentIndex.keys()).forEach(key => {
      if (this.componentIndex.get(key)?.moduleName === moduleName) {
        this.componentIndex.delete(key);
      }
    });

    // Add all components/services/hooks
    const allItems = [
      ...(module.components || []),
      ...(module.services || []),
      ...(module.hooks || [])
    ];

    allItems.forEach(item => {
      this.componentIndex.set(item.name, { moduleName, component: item });
    });
  }

  /**
   * Batch register multiple modules
   */
  registerBatch(modules: RegisteredModule[]) {
    console.log(`ðŸ“ Batch registering ${modules.length} modules`);
    
    modules.forEach(module => {
      this.modules.set(module.moduleName, {
        ...module,
        lastUpdated: new Date().toISOString()
      });
      
      this.updateComponentIndex(module.moduleName, module);
    });

    this.notifyListeners();
  }

  /**
   * Get all registered modules
   */
  getAll(): RegisteredModule[] {
    return Array.from(this.modules.values());
  }

  /**
   * Get modules by status
   */
  getByStatus(status: RegisteredModule['status']): RegisteredModule[] {
    return this.getAll().filter(module => module.status === status);
  }

  /**
   * Get auto-generated modules
   */
  getAutoGenerated(): RegisteredModule[] {
    return this.getAll().filter(module => module.isAutoGenerated);
  }

  /**
   * Get a specific module by name
   */
  get(moduleName: string): RegisteredModule | undefined {
    return this.modules.get(moduleName);
  }

  /**
   * Check if a module exists
   */
  exists(moduleName: string): boolean {
    return this.modules.has(moduleName);
  }

  /**
   * Remove a module
   */
  remove(moduleName: string): boolean {
    const module = this.modules.get(moduleName);
    const removed = this.modules.delete(moduleName);
    
    if (removed && module) {
      // Remove from component index
      this.updateComponentIndex(moduleName, { ...module, components: [], services: [], hooks: [] });
      this.notifyListeners();
    }
    
    return removed;
  }

  /**
   * Update auto-registration configuration
   */
  updateAutoConfig(config: Partial<AutoRegistrationConfig>) {
    this.autoConfig = { ...this.autoConfig, ...config };
    console.log('ðŸ”§ Auto-registration config updated:', this.autoConfig);
  }

  /**
   * Get auto-registration configuration
   */
  getAutoConfig(): AutoRegistrationConfig {
    return { ...this.autoConfig };
  }

  /**
   * Subscribe to module changes
   */
  subscribe(listener: (modules: RegisteredModule[]) => void) {
    this.listeners.add(listener);
    return () => this.listeners.delete(listener);
  }

  /**
   * Get registry statistics with component/service info
   */
  getStats() {
    const modules = this.getAll();
    const allComponents = this.getAllComponents();
    
    return {
      total: modules.length,
      active: modules.filter(m => m.status === 'active').length,
      deprecated: modules.filter(m => m.status === 'deprecated').length,
      development: modules.filter(m => m.status === 'development').length,
      autoGenerated: modules.filter(m => m.isAutoGenerated).length,
      totalComponents: allComponents.filter(({ component }) => component.type === 'component').length,
      totalServices: allComponents.filter(({ component }) => component.type === 'service').length,
      totalHooks: allComponents.filter(({ component }) => component.type === 'hook').length,
      protectedComponents: allComponents.filter(({ component }) => component.isProtected).length,
      lastUpdated: modules.reduce((latest, module) => {
        const moduleDate = new Date(module.lastUpdated);
        return moduleDate > latest ? moduleDate : latest;
      }, new Date(0))
    };
  }

  /**
   * Search modules by name, description, or component
   */
  search(query: string): RegisteredModule[] {
    const lowercaseQuery = query.toLowerCase();
    return this.getAll().filter(module => 
      module.moduleName.toLowerCase().includes(lowercaseQuery) ||
      module.tableName.toLowerCase().includes(lowercaseQuery) ||
      (module.description && module.description.toLowerCase().includes(lowercaseQuery)) ||
      this.moduleHasMatchingComponent(module, lowercaseQuery)
    );
  }

  /**
   * Check if module has matching component
   */
  private moduleHasMatchingComponent(module: RegisteredModule, query: string): boolean {
    const allItems = [
      ...(module.components || []),
      ...(module.services || []),
      ...(module.hooks || [])
    ];
    
    return allItems.some(item => 
      item.name.toLowerCase().includes(query) ||
      item.permissions.some(perm => perm.toLowerCase().includes(query))
    );
  }

  /**
   * Export registry configuration with components
   */
  export(): { modules: RegisteredModule[]; config: AutoRegistrationConfig; componentStats: any } {
    return {
      modules: this.getAll(),
      config: this.getAutoConfig(),
      componentStats: this.getStats()
    };
  }

  /**
   * Import registry configuration
   */
  import(data: { modules: RegisteredModule[]; config?: AutoRegistrationConfig }) {
    console.log(`ðŸ“¥ Importing ${data.modules.length} modules with components/services`);
    
    // Clear existing modules and component index
    this.modules.clear();
    this.componentIndex.clear();
    
    // Import modules
    data.modules.forEach(module => {
      this.modules.set(module.moduleName, module);
      this.updateComponentIndex(module.moduleName, module);
    });
    
    // Import config if provided
    if (data.config) {
      this.autoConfig = data.config;
    }
    
    this.notifyListeners();
  }

  private validateModule(module: RegisteredModule): boolean {
    // Enhanced validation logic
    if (!module.moduleName || !module.tableName) return false;
    if (!module.requiredFields || !Array.isArray(module.requiredFields)) return false;
    if (!module.version || !module.lastUpdated) return false;
    return true;
  }

  private notifyListeners() {
    const modules = this.getAll();
    this.listeners.forEach(listener => listener(modules));
  }
}

// Global module registry instance
export const moduleRegistry = new ModuleRegistry();

// Pre-register existing modules with enhanced metadata and components including REAL existing components
moduleRegistry.register({
  moduleName: 'Users',
  tableName: 'profiles',
  requiredFields: ['email', 'first_name'],
  optionalFields: ['last_name', 'phone'],
  version: '1.0.0',
  lastUpdated: new Date().toISOString(),
  dependencies: ['auth'],
  status: 'active',
  isAutoGenerated: false,
  description: 'User profile management system',
  components: [
    {
      name: 'UsersList',
      type: 'component',
      filePath: 'src/components/users/UsersList.tsx',
      permissions: ['users_read', 'users_list'],
      isProtected: true,
      lastModified: new Date().toISOString()
    },
    {
      name: 'CreateUserDialog',
      type: 'component',
      filePath: 'src/components/users/CreateUserDialog.tsx',
      permissions: ['users_create', 'users_write'],
      isProtected: true,
      lastModified: new Date().toISOString()
    },
    {
      name: 'EditUserDialog',
      type: 'component',
      filePath: 'src/components/users/EditUserDialog.tsx', 
      permissions: ['users_update', 'users_write'],
      isProtected: true,
      lastModified: new Date().toISOString()
    },
    {
      name: 'AssignRoleDialog',
      type: 'component',
      filePath: 'src/components/users/AssignRoleDialog.tsx',
      permissions: ['users_assign_roles', 'roles_write'],
      isProtected: true,
      lastModified: new Date().toISOString()
    }
  ],
  hooks: [
    {
      name: 'useUsers',
      type: 'hook',
      filePath: 'src/hooks/useUsers.tsx',
      permissions: ['users_read'],
      isProtected: true,
      lastModified: new Date().toISOString()
    },
    {
      name: 'useUserMutations',
      type: 'hook',
      filePath: 'src/hooks/mutations/useUserMutations.tsx',
      permissions: ['users_write'],
      isProtected: true,
      lastModified: new Date().toISOString()
    }
  ]
});

moduleRegistry.register({
  moduleName: 'Facilities',
  tableName: 'facilities',
  requiredFields: ['name', 'facility_type'],
  optionalFields: ['address', 'phone'],
  version: '1.0.0',
  lastUpdated: new Date().toISOString(),
  dependencies: [],
  status: 'active',
  isAutoGenerated: false,
  description: 'Healthcare facility management',
  components: [
    {
      name: 'FacilitiesList',
      type: 'component',
      filePath: 'src/components/facilities/FacilitiesList.tsx',
      permissions: ['facilities_read', 'facilities_list'],
      isProtected: true,
      lastModified: new Date().toISOString()
    },
    {
      name: 'CreateFacilityDialog',
      type: 'component',
      filePath: 'src/components/facilities/CreateFacilityDialog.tsx',
      permissions: ['facilities_create', 'facilities_write'],
      isProtected: true,
      lastModified: new Date().toISOString()
    },
    {
      name: 'EditFacilityDialog',
      type: 'component',
      filePath: 'src/components/facilities/EditFacilityDialog.tsx',
      permissions: ['facilities_update', 'facilities_write'],
      isProtected: true,
      lastModified: new Date().toISOString()
    }
  ],
  hooks: [
    {
      name: 'useFacilities',
      type: 'hook',
      filePath: 'src/hooks/useFacilities.tsx',
      permissions: ['facilities_read'],
      isProtected: true,
      lastModified: new Date().toISOString()
    }
  ]
});

moduleRegistry.register({
  moduleName: 'Modules',
  tableName: 'modules',
  requiredFields: ['name'],
  optionalFields: ['description'],
  version: '1.0.0',
  lastUpdated: new Date().toISOString(),
  dependencies: [],
  status: 'active',
  isAutoGenerated: false,
  description: 'Module management and RBAC system',
  components: [
    {
      name: 'ModuleList',
      type: 'component',
      filePath: 'src/components/modules/ModuleList.tsx',
      permissions: ['modules_read', 'modules_list'],
      isProtected: true,
      lastModified: new Date().toISOString()
    },
    {
      name: 'CreateModuleDialog',
      type: 'component',
      filePath: 'src/components/modules/CreateModuleDialog.tsx',
      permissions: ['modules_create', 'modules_write'],
      isProtected: true,
      lastModified: new Date().toISOString()
    },
    {
      name: 'ModuleAssignmentDialog',
      type: 'component',
      filePath: 'src/components/modules/ModuleAssignmentDialog.tsx',
      permissions: ['modules_assign', 'modules_write'],
      isProtected: true,
      lastModified: new Date().toISOString()
    },
    {
      name: 'AutoModuleManager',
      type: 'component',
      filePath: 'src/components/admin/AutoModuleManager/index.tsx',
      permissions: ['modules_admin', 'modules_auto_detect'],
      isProtected: true,
      lastModified: new Date().toISOString()
    }
  ],
  hooks: [
    {
      name: 'useModules',
      type: 'hook',
      filePath: 'src/hooks/useModules.tsx',
      permissions: ['modules_read'],
      isProtected: true,
      lastModified: new Date().toISOString()
    }
  ]
});

// Enhanced registration function
export const registerNewModule = (module: Omit<RegisteredModule, 'lastUpdated'>) => {
  moduleRegistry.register({
    ...module,
    lastUpdated: new Date().toISOString()
  });
};

// Component registration functions
export const registerComponentToModule = (moduleName: string, component: ComponentServiceInfo) => {
  moduleRegistry.addComponentToModule(moduleName, component);
};

// Convenience functions for auto-registration
export const enableAutoRegistration = (config?: Partial<AutoRegistrationConfig>) => {
  moduleRegistry.updateAutoConfig({ enabled: true, ...config });
};

export const disableAutoRegistration = () => {
  moduleRegistry.updateAutoConfig({ enabled: false });
};
