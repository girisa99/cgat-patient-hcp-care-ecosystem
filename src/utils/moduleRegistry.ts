
/**
 * Enhanced Module Registry System
 * 
 * This system maintains a registry of all modules and their configurations,
 * enabling real-time updates, validation, and automatic registration.
 */

import { ModuleConfig } from './moduleValidation';

export interface RegisteredModule extends ModuleConfig {
  version: string;
  lastUpdated: string;
  dependencies: string[];
  status: 'active' | 'deprecated' | 'development';
  isAutoGenerated?: boolean;
  confidence?: number;
  description?: string;
}

export interface AutoRegistrationConfig {
  enabled: boolean;
  confidenceThreshold: number;
  scanIntervalMs: number;
  autoGenerateCode: boolean;
}

class ModuleRegistry {
  private modules: Map<string, RegisteredModule> = new Map();
  private listeners: Set<(modules: RegisteredModule[]) => void> = new Set();
  private autoConfig: AutoRegistrationConfig = {
    enabled: false,
    confidenceThreshold: 0.8,
    scanIntervalMs: 30000,
    autoGenerateCode: true
  };

  /**
   * Register a new module or update existing one
   */
  register(module: RegisteredModule) {
    console.log(`📝 Registering module: ${module.moduleName}`);
    
    const existing = this.modules.get(module.moduleName);
    if (existing) {
      console.log(`🔄 Updating existing module: ${module.moduleName}`);
    }

    this.modules.set(module.moduleName, {
      ...module,
      lastUpdated: new Date().toISOString()
    });

    this.notifyListeners();
  }

  /**
   * Batch register multiple modules
   */
  registerBatch(modules: RegisteredModule[]) {
    console.log(`📝 Batch registering ${modules.length} modules`);
    
    modules.forEach(module => {
      this.modules.set(module.moduleName, {
        ...module,
        lastUpdated: new Date().toISOString()
      });
    });

    this.notifyListeners();
  }

  /**
   * Get all registered modules
   */
  getAll(): RegisteredModule[] {
    return Array.from(this.modules.values());
  }

  /**
   * Get modules by status
   */
  getByStatus(status: RegisteredModule['status']): RegisteredModule[] {
    return this.getAll().filter(module => module.status === status);
  }

  /**
   * Get auto-generated modules
   */
  getAutoGenerated(): RegisteredModule[] {
    return this.getAll().filter(module => module.isAutoGenerated);
  }

  /**
   * Get a specific module by name
   */
  get(moduleName: string): RegisteredModule | undefined {
    return this.modules.get(moduleName);
  }

  /**
   * Check if a module exists
   */
  exists(moduleName: string): boolean {
    return this.modules.has(moduleName);
  }

  /**
   * Remove a module
   */
  remove(moduleName: string): boolean {
    const removed = this.modules.delete(moduleName);
    if (removed) {
      this.notifyListeners();
    }
    return removed;
  }

  /**
   * Update auto-registration configuration
   */
  updateAutoConfig(config: Partial<AutoRegistrationConfig>) {
    this.autoConfig = { ...this.autoConfig, ...config };
    console.log('🔧 Auto-registration config updated:', this.autoConfig);
  }

  /**
   * Get auto-registration configuration
   */
  getAutoConfig(): AutoRegistrationConfig {
    return { ...this.autoConfig };
  }

  /**
   * Subscribe to module changes
   */
  subscribe(listener: (modules: RegisteredModule[]) => void) {
    this.listeners.add(listener);
    return () => this.listeners.delete(listener);
  }

  /**
   * Validate all modules
   */
  validateAll() {
    const results = Array.from(this.modules.entries()).map(([name, module]) => ({
      name,
      isValid: this.validateModule(module),
      module
    }));

    const invalid = results.filter(r => !r.isValid);
    if (invalid.length > 0) {
      console.warn('⚠️ Invalid modules found:', invalid.map(r => r.name));
    }

    return results;
  }

  /**
   * Get registry statistics
   */
  getStats() {
    const modules = this.getAll();
    return {
      total: modules.length,
      active: modules.filter(m => m.status === 'active').length,
      deprecated: modules.filter(m => m.status === 'deprecated').length,
      development: modules.filter(m => m.status === 'development').length,
      autoGenerated: modules.filter(m => m.isAutoGenerated).length,
      lastUpdated: modules.reduce((latest, module) => {
        const moduleDate = new Date(module.lastUpdated);
        return moduleDate > latest ? moduleDate : latest;
      }, new Date(0))
    };
  }

  /**
   * Search modules by name or description
   */
  search(query: string): RegisteredModule[] {
    const lowercaseQuery = query.toLowerCase();
    return this.getAll().filter(module => 
      module.moduleName.toLowerCase().includes(lowercaseQuery) ||
      module.tableName.toLowerCase().includes(lowercaseQuery) ||
      (module.description && module.description.toLowerCase().includes(lowercaseQuery))
    );
  }

  /**
   * Export registry configuration
   */
  export(): { modules: RegisteredModule[]; config: AutoRegistrationConfig } {
    return {
      modules: this.getAll(),
      config: this.getAutoConfig()
    };
  }

  /**
   * Import registry configuration
   */
  import(data: { modules: RegisteredModule[]; config?: AutoRegistrationConfig }) {
    console.log(`📥 Importing ${data.modules.length} modules`);
    
    // Clear existing modules
    this.modules.clear();
    
    // Import modules
    data.modules.forEach(module => {
      this.modules.set(module.moduleName, module);
    });
    
    // Import config if provided
    if (data.config) {
      this.autoConfig = data.config;
    }
    
    this.notifyListeners();
  }

  private validateModule(module: RegisteredModule): boolean {
    // Enhanced validation logic
    if (!module.moduleName || !module.tableName) return false;
    if (!module.requiredFields || !Array.isArray(module.requiredFields)) return false;
    if (!module.version || !module.lastUpdated) return false;
    return true;
  }

  private notifyListeners() {
    const modules = this.getAll();
    this.listeners.forEach(listener => listener(modules));
  }
}

// Global module registry instance
export const moduleRegistry = new ModuleRegistry();

// Pre-register existing modules with enhanced metadata
moduleRegistry.register({
  moduleName: 'Users',
  tableName: 'profiles',
  requiredFields: ['email', 'first_name'],
  optionalFields: ['last_name', 'phone'],
  version: '1.0.0',
  lastUpdated: new Date().toISOString(),
  dependencies: ['auth'],
  status: 'active',
  isAutoGenerated: false,
  description: 'User profile management system'
});

moduleRegistry.register({
  moduleName: 'Facilities',
  tableName: 'facilities',
  requiredFields: ['name', 'facility_type'],
  optionalFields: ['address', 'phone'],
  version: '1.0.0',
  lastUpdated: new Date().toISOString(),
  dependencies: [],
  status: 'active',
  isAutoGenerated: false,
  description: 'Healthcare facility management'
});

// Enhanced registration function
export const registerNewModule = (module: Omit<RegisteredModule, 'lastUpdated'>) => {
  moduleRegistry.register({
    ...module,
    lastUpdated: new Date().toISOString()
  });
};

// Convenience functions for auto-registration
export const enableAutoRegistration = (config?: Partial<AutoRegistrationConfig>) => {
  moduleRegistry.updateAutoConfig({ enabled: true, ...config });
};

export const disableAutoRegistration = () => {
  moduleRegistry.updateAutoConfig({ enabled: false });
};
