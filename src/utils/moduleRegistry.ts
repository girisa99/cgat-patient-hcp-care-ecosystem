
/**
 * Module Registry - Single Source of Truth for Module Management
 * Centralized registry for all module configurations and metadata
 */

export interface ModuleConfig {
  id: string;
  name: string;
  description?: string;
  tableName: string;
  requiredFields: string[];
  customValidation?: (data: any) => boolean;
  isActive: boolean;
  createdAt: string;
  lastSync?: string;
}

export interface ComponentServiceInfo {
  name: string;
  type: 'component' | 'service' | 'hook';
  isProtected: boolean;
  lastModified: string;
  permissions?: string[];
}

export interface RegisteredModule {
  moduleName: string;
  tableName: string;
  requiredFields: string[];
  optionalFields?: string[];
  version: string;
  lastUpdated: Date;
  status: 'active' | 'deprecated' | 'development';
  description?: string;
  isAutoGenerated?: boolean;
  confidenceScore?: number;
  components?: ComponentServiceInfo[];
  services?: ComponentServiceInfo[];
  hooks?: ComponentServiceInfo[];
}

export interface AutoRegistrationConfig {
  enabled: boolean;
  confidenceThreshold: number;
  scanIntervalMs: number;
  autoGenerateCode: boolean;
  trackComponents: boolean;
  trackServices: boolean;
}

export interface RegistryStats {
  total: number;
  active: number;
  deprecated: number;
  development: number;
  autoGenerated: number;
  totalComponents: number;
  totalServices: number;
  totalHooks: number;
  protectedComponents: number;
  lastUpdated: Date;
  totalModules: number;
  activeModules: number;
  tablesUsed: number;
  lastRegistration: number | null;
}

export interface ModuleRegistry {
  modules: Map<string, ModuleConfig>;
  registrationOrder: string[];
}

class ModuleRegistryManager {
  private registry: ModuleRegistry = {
    modules: new Map(),
    registrationOrder: []
  };

  private registeredModules: Map<string, RegisteredModule> = new Map();
  private autoConfig: AutoRegistrationConfig = {
    enabled: false,
    confidenceThreshold: 0.8,
    scanIntervalMs: 30000,
    autoGenerateCode: true,
    trackComponents: true,
    trackServices: true
  };

  /**
   * Register a new module configuration
   */
  registerModule(config: Omit<ModuleConfig, 'createdAt' | 'isActive'>): void {
    const moduleConfig: ModuleConfig = {
      ...config,
      isActive: true,
      createdAt: new Date().toISOString()
    };

    this.registry.modules.set(config.id, moduleConfig);
    
    if (!this.registry.registrationOrder.includes(config.id)) {
      this.registry.registrationOrder.push(config.id);
    }

    console.log(`📦 Module registered: ${config.name}`);
  }

  /**
   * Register a module with full configuration
   */
  register(module: RegisteredModule): void {
    this.registeredModules.set(module.moduleName, module);
    console.log(`✅ Module registered: ${module.moduleName}`);
  }

  /**
   * Check if module is registered
   */
  isRegistered(moduleName: string): boolean {
    return this.registeredModules.has(moduleName) || this.registry.modules.has(moduleName);
  }

  /**
   * Get all registered modules
   */
  getAllModules(): ModuleConfig[] {
    return Array.from(this.registry.modules.values())
      .filter(module => module.isActive)
      .sort((a, b) => a.name.localeCompare(b.name));
  }

  /**
   * Get all registered modules (new format)
   */
  getAll(): RegisteredModule[] {
    return Array.from(this.registeredModules.values());
  }

  /**
   * Get module by ID
   */
  getModule(id: string): ModuleConfig | undefined {
    return this.registry.modules.get(id);
  }

  /**
   * Get module by name (new format)
   */
  get(moduleName: string): RegisteredModule | undefined {
    return this.registeredModules.get(moduleName);
  }

  /**
   * Check if module exists
   */
  hasModule(id: string): boolean {
    return this.registry.modules.has(id);
  }

  /**
   * Get modules by table name
   */
  getModulesByTable(tableName: string): ModuleConfig[] {
    return this.getAllModules().filter(module => module.tableName === tableName);
  }

  /**
   * Update module sync status
   */
  updateModuleSync(id: string): void {
    const module = this.registry.modules.get(id);
    if (module) {
      module.lastSync = new Date().toISOString();
      this.registry.modules.set(id, module);
    }
  }

  /**
   * Get all components across all modules
   */
  getAllComponents(): { moduleName: string; component: ComponentServiceInfo }[] {
    const result: { moduleName: string; component: ComponentServiceInfo }[] = [];
    
    this.registeredModules.forEach((module, moduleName) => {
      const allItems = [
        ...(module.components || []),
        ...(module.services || []),
        ...(module.hooks || [])
      ];
      
      allItems.forEach(component => {
        result.push({ moduleName, component });
      });
    });
    
    return result;
  }

  /**
   * Get components for RBAC
   */
  getModuleComponentsForRBAC(moduleName: string): ComponentServiceInfo[] {
    const module = this.registeredModules.get(moduleName);
    if (!module) {
      return [];
    }

    return [
      ...(module.components || []),
      ...(module.services || []),
      ...(module.hooks || [])
    ];
  }

  /**
   * Get auto registration config
   */
  getAutoConfig(): AutoRegistrationConfig {
    return { ...this.autoConfig };
  }

  /**
   * Update auto registration config
   */
  updateAutoConfig(config: Partial<AutoRegistrationConfig>): void {
    this.autoConfig = { ...this.autoConfig, ...config };
  }

  /**
   * Export registry data
   */
  export(): { modules: RegisteredModule[]; config: AutoRegistrationConfig; stats: RegistryStats } {
    return {
      modules: this.getAll(),
      config: this.getAutoConfig(),
      stats: this.getStats()
    };
  }

  /**
   * Import registry data
   */
  import(data: { modules: RegisteredModule[]; config: AutoRegistrationConfig; stats: RegistryStats }): void {
    this.registeredModules.clear();
    data.modules.forEach(module => {
      this.registeredModules.set(module.moduleName, module);
    });
    this.autoConfig = data.config;
    console.log(`✅ Registry imported with ${data.modules.length} modules`);
  }

  /**
   * Add component to module
   */
  addComponentToModule(moduleName: string, component: ComponentServiceInfo): void {
    const module = this.registeredModules.get(moduleName);
    if (!module) {
      console.warn(`Module ${moduleName} not found`);
      return;
    }

    if (!module.components) module.components = [];
    module.components.push(component);
    module.lastUpdated = new Date();
  }

  /**
   * Get registry statistics
   */
  getStats(): RegistryStats {
    const modules = this.getAll();
    const allComponents = this.getAllComponents();
    const legacyModules = this.getAllModules();
    
    return {
      total: modules.length,
      active: modules.filter(m => m.status === 'active').length,
      deprecated: modules.filter(m => m.status === 'deprecated').length,
      development: modules.filter(m => m.status === 'development').length,
      autoGenerated: modules.filter(m => m.isAutoGenerated).length,
      totalComponents: allComponents.filter(c => c.component.type === 'component').length,
      totalServices: allComponents.filter(c => c.component.type === 'service').length,
      totalHooks: allComponents.filter(c => c.component.type === 'hook').length,
      protectedComponents: allComponents.filter(c => c.component.isProtected).length,
      lastUpdated: new Date(),
      // Legacy compatibility
      totalModules: legacyModules.length,
      activeModules: legacyModules.filter(m => m.isActive).length,
      tablesUsed: [...new Set([...modules.map(m => m.tableName), ...legacyModules.map(m => m.tableName)])].length,
      lastRegistration: modules.length > 0 ? 
        Math.max(...modules.map(m => new Date(m.lastUpdated).getTime())) : null
    };
  }

  /**
   * Unregister module
   */
  unregister(moduleName: string): boolean {
    return this.registeredModules.delete(moduleName);
  }

  /**
   * Get active modules
   */
  getActiveModules(): RegisteredModule[] {
    return this.getAll().filter(module => module.status === 'active');
  }

  /**
   * Get auto-generated modules
   */
  getAutoGeneratedModules(): RegisteredModule[] {
    return this.getAll().filter(module => module.isAutoGenerated === true);
  }
}

// Create singleton instance
const moduleRegistryManager = new ModuleRegistryManager();

// Pre-register core modules for single source of truth
moduleRegistryManager.registerModule({
  id: 'users',
  name: 'Users Management',
  description: 'Unified user management system',
  tableName: 'profiles',
  requiredFields: ['email', 'first_name']
});

moduleRegistryManager.registerModule({
  id: 'patients',
  name: 'Patients Management', 
  description: 'Patient caregivers filtered from users',
  tableName: 'profiles',
  requiredFields: ['email', 'first_name', 'role']
});

moduleRegistryManager.registerModule({
  id: 'facilities',
  name: 'Facilities Management',
  description: 'Healthcare facilities management',
  tableName: 'facilities',
  requiredFields: ['name', 'facility_type']
});

moduleRegistryManager.registerModule({
  id: 'modules',
  name: 'Modules Management',
  description: 'System modules registry',
  tableName: 'modules',
  requiredFields: ['name']
});

moduleRegistryManager.registerModule({
  id: 'api-services',
  name: 'API Services Management',
  description: 'API integration services',
  tableName: 'api_integration_registry',
  requiredFields: ['name', 'type', 'direction']
});

// Also register them in the new format for consistency
moduleRegistryManager.register({
  moduleName: 'Users',
  tableName: 'profiles',
  requiredFields: ['id', 'email'],
  optionalFields: ['first_name', 'last_name'],
  version: '1.0.0',
  lastUpdated: new Date(),
  status: 'active',
  description: 'User management module'
});

moduleRegistryManager.register({
  moduleName: 'Facilities',
  tableName: 'facilities',
  requiredFields: ['id', 'name'],
  optionalFields: ['address', 'phone'],
  version: '1.0.0',
  lastUpdated: new Date(),
  status: 'active',
  description: 'Facility management module'
});

moduleRegistryManager.register({
  moduleName: 'ApiServices',
  tableName: 'api_integration_registry',
  requiredFields: ['id', 'name', 'type'],
  optionalFields: ['description', 'base_url'],
  version: '1.0.0',
  lastUpdated: new Date(),
  status: 'active',
  description: 'API Services management module'
});

console.log('🏗️ Module Registry initialized with', moduleRegistryManager.getStats().totalModules, 'core modules');

export const moduleRegistry = moduleRegistryManager;
