
/**
 * Module Detection Utilities
 * Focused on detecting and analyzing new modules
 */

import { supabase } from '@/integrations/supabase/client';
import { moduleRegistry } from '../moduleRegistry';
import { SchemaAnalysis, analyzeTable, calculateConfidence } from './schemaAnalyzer';
import { AutoModuleConfig } from './types';

/**
 * Scans the database schema and returns analysis for all tables
 */
export const scanDatabaseSchema = async (): Promise<SchemaAnalysis[]> => {
  console.log('üîç Scanning database schema for new tables...');
  
  try {
    // Return analysis for all known tables, not just new ones
    return await analyzeKnownTables();
    
  } catch (error) {
    console.error('‚ùå Schema scanning failed:', error);
    return await analyzeKnownTables();
  }
};

/**
 * Analyze all known tables including existing ones
 */
const analyzeKnownTables = async (): Promise<SchemaAnalysis[]> => {
  // Include tables that might need component registration
  const knownTables = [
    'profiles', 'facilities', 'modules', 'roles', 'permissions', 
    'user_roles', 'audit_logs', 'role_permissions', 'user_permissions',
    'module_permissions', 'user_facility_access', 'role_module_assignments',
    'user_module_assignments', 'role_permission_overrides', 'api_keys',
    'developer_applications', 'external_api_registry'
  ];
  
  const analyses: SchemaAnalysis[] = [];
  
  for (const tableName of knownTables) {
    const analysis = await analyzeTable(tableName);
    if (analysis) {
      analyses.push(analysis);
    }
  }
  
  console.log(`üìä Analyzed ${analyses.length} tables`);
  return analyses;
};

/**
 * Auto-detects modules that need component registration or are completely new
 */
export const detectNewModules = async (): Promise<AutoModuleConfig[]> => {
  console.log('üîç Detecting modules needing component registration...');
  
  const analyses = await scanDatabaseSchema();
  const existingModules = moduleRegistry.getAll();
  
  const modulesToRegister: AutoModuleConfig[] = [];

  for (const analysis of analyses) {
    // Check if module exists in registry
    const existingModule = existingModules.find(m => 
      m.tableName === analysis.tableName || 
      m.moduleName === analysis.suggestedModuleName
    );

    // If module doesn't exist at all, or exists but has no components
    const needsRegistration = !existingModule || 
      (!existingModule.components?.length && 
       !existingModule.services?.length && 
       !existingModule.hooks?.length);

    if (needsRegistration) {
      // Calculate confidence score
      const confidence = calculateConfidence(analysis);

      // Generate suggested custom columns
      const suggestedCustomColumns = generateCustomColumns(analysis);

      const autoConfig: AutoModuleConfig = {
        tableName: analysis.tableName,
        moduleName: analysis.suggestedModuleName,
        requiredFields: analysis.suggestedRequiredFields,
        optionalFields: analysis.suggestedOptionalFields,
        isAutoGenerated: true,
        confidence,
        suggestedCustomColumns
      };

      modulesToRegister.push(autoConfig);
      console.log(`üìù Module ${autoConfig.moduleName} needs registration (confidence: ${Math.round(confidence * 100)}%)`);
    }
  }

  console.log(`‚úÖ Detected ${modulesToRegister.length} modules for registration`);
  return modulesToRegister;
};

/**
 * Generates suggested custom columns based on table structure
 */
const generateCustomColumns = (analysis: SchemaAnalysis) => {
  const columns = [];

  // Add name column if exists
  if (analysis.columns.some(col => col.name === 'name' || col.name === 'title')) {
    columns.push({
      key: 'name',
      header: 'Name',
      type: 'text' as const
    });
  }

  // Add status column if exists
  if (analysis.hasStatus) {
    columns.push({
      key: 'status',
      header: 'Status',
      type: 'status' as const
    });
  }

  // Add created_at if exists
  if (analysis.hasCreatedAt) {
    columns.push({
      key: 'created_at',
      header: 'Created',
      type: 'date' as const
    });
  }

  return columns;
};
