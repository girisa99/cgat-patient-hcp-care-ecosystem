
/**
 * Automatic Schema Scanner
 * 
 * This utility scans the database schema and automatically detects new tables,
 * suggests module configurations, and generates boilerplate code.
 */

import { supabase } from '@/integrations/supabase/client';
import { Database } from '@/integrations/supabase/types';
import { ModuleConfig } from './moduleValidation';
import { moduleRegistry } from './moduleRegistry';

type DatabaseTables = keyof Database['public']['Tables'];

export interface SchemaAnalysis {
  tableName: string;
  columns: {
    name: string;
    type: string;
    nullable: boolean;
    defaultValue?: string;
  }[];
  suggestedModuleName: string;
  suggestedRequiredFields: string[];
  suggestedOptionalFields: string[];
  hasCreatedAt: boolean;
  hasUpdatedAt: boolean;
  hasStatus: boolean;
  hasUserId: boolean;
}

export interface AutoModuleConfig extends ModuleConfig {
  isAutoGenerated: boolean;
  confidence: number; // 0-1 confidence score
  suggestedCustomColumns?: Array<{
    key: string;
    header: string;
    type: 'text' | 'status' | 'date' | 'boolean';
  }>;
}

/**
 * Scans the database schema and returns analysis for all tables
 */
export const scanDatabaseSchema = async (): Promise<SchemaAnalysis[]> => {
  console.log('üîç Scanning database schema for new tables...');
  
  try {
    // Use raw SQL query to get table information
    const { data: tables, error } = await supabase
      .rpc('exec_sql', {
        sql: `
          SELECT table_name 
          FROM information_schema.tables 
          WHERE table_schema = 'public' 
          AND table_type = 'BASE TABLE'
          AND table_name NOT LIKE 'auth_%'
          AND table_name NOT LIKE 'storage_%'
        `
      });

    if (error) {
      console.error('‚ùå Error scanning tables:', error);
      return [];
    }

    const analyses: SchemaAnalysis[] = [];

    // Analyze each table
    for (const table of tables || []) {
      const analysis = await analyzeTable(table.table_name);
      if (analysis) {
        analyses.push(analysis);
      }
    }

    console.log(`‚úÖ Analyzed ${analyses.length} tables`);
    return analyses;
    
  } catch (error) {
    console.error('‚ùå Schema scanning failed:', error);
    // Return analysis for known tables as fallback
    return await analyzeKnownTables();
  }
};

/**
 * Fallback method to analyze known tables
 */
const analyzeKnownTables = async (): Promise<SchemaAnalysis[]> => {
  const knownTables = ['profiles', 'facilities', 'modules', 'roles', 'permissions'];
  const analyses: SchemaAnalysis[] = [];
  
  for (const tableName of knownTables) {
    const analysis = await analyzeTable(tableName);
    if (analysis) {
      analyses.push(analysis);
    }
  }
  
  return analyses;
};

/**
 * Analyzes a specific table structure
 */
const analyzeTable = async (tableName: string): Promise<SchemaAnalysis | null> => {
  try {
    // Use raw SQL query to get column information
    const { data: columns, error } = await supabase
      .rpc('exec_sql', {
        sql: `
          SELECT 
            column_name, 
            data_type, 
            is_nullable, 
            column_default
          FROM information_schema.columns 
          WHERE table_name = '${tableName}' 
          AND table_schema = 'public'
        `
      });

    if (error || !columns) {
      console.warn(`‚ö†Ô∏è Could not analyze table ${tableName}`);
      return createFallbackAnalysis(tableName);
    }

    const columnData = columns.map((col: any) => ({
      name: col.column_name,
      type: col.data_type,
      nullable: col.is_nullable === 'YES',
      defaultValue: col.column_default
    }));

    return createAnalysisFromColumns(tableName, columnData);
    
  } catch (error) {
    console.error(`‚ùå Error analyzing table ${tableName}:`, error);
    return createFallbackAnalysis(tableName);
  }
};

/**
 * Creates analysis from column data
 */
const createAnalysisFromColumns = (tableName: string, columnData: any[]): SchemaAnalysis => {
  // Analyze table structure
  const hasCreatedAt = columnData.some(col => col.name === 'created_at');
  const hasUpdatedAt = columnData.some(col => col.name === 'updated_at');
  const hasStatus = columnData.some(col => col.name === 'status');
  const hasUserId = columnData.some(col => col.name === 'user_id');

  // Generate suggested module name (PascalCase from table name)
  const suggestedModuleName = toPascalCase(tableName);

  // Determine required and optional fields
  const requiredFields = columnData
    .filter(col => !col.nullable && col.name !== 'id' && !col.defaultValue)
    .map(col => col.name);

  const optionalFields = columnData
    .filter(col => col.nullable || col.defaultValue)
    .filter(col => col.name !== 'id' && col.name !== 'created_at' && col.name !== 'updated_at')
    .map(col => col.name);

  return {
    tableName,
    columns: columnData,
    suggestedModuleName,
    suggestedRequiredFields: requiredFields,
    suggestedOptionalFields: optionalFields,
    hasCreatedAt,
    hasUpdatedAt,
    hasStatus,
    hasUserId
  };
};

/**
 * Creates fallback analysis for tables when schema scanning fails
 */
const createFallbackAnalysis = (tableName: string): SchemaAnalysis => {
  // Create basic analysis based on table name
  const suggestedModuleName = toPascalCase(tableName);
  
  // Common patterns for different table types
  const commonColumns = {
    profiles: ['first_name', 'last_name', 'email'],
    facilities: ['name', 'facility_type'],
    modules: ['name', 'description'],
    roles: ['name'],
    permissions: ['name']
  };
  
  const requiredFields = commonColumns[tableName as keyof typeof commonColumns] || ['name'];
  
  return {
    tableName,
    columns: [],
    suggestedModuleName,
    suggestedRequiredFields: requiredFields,
    suggestedOptionalFields: ['description'],
    hasCreatedAt: true,
    hasUpdatedAt: true,
    hasStatus: false,
    hasUserId: false
  };
};

/**
 * Auto-detects new tables and suggests module configurations
 */
export const detectNewModules = async (): Promise<AutoModuleConfig[]> => {
  console.log('üîç Detecting new modules...');
  
  const analyses = await scanDatabaseSchema();
  const existingModules = moduleRegistry.getAll();
  const existingTableNames = existingModules.map(m => m.tableName);

  const newModules: AutoModuleConfig[] = [];

  for (const analysis of analyses) {
    // Skip if module already exists
    if (existingTableNames.includes(analysis.tableName)) {
      continue;
    }

    // Calculate confidence score
    const confidence = calculateConfidence(analysis);

    // Generate suggested custom columns
    const suggestedCustomColumns = generateCustomColumns(analysis);

    const autoConfig: AutoModuleConfig = {
      tableName: analysis.tableName,
      moduleName: analysis.suggestedModuleName,
      requiredFields: analysis.suggestedRequiredFields,
      optionalFields: analysis.suggestedOptionalFields,
      isAutoGenerated: true,
      confidence,
      suggestedCustomColumns
    };

    newModules.push(autoConfig);
  }

  console.log(`‚úÖ Detected ${newModules.length} new modules`);
  return newModules;
};

/**
 * Calculates confidence score for auto-generated module
 */
const calculateConfidence = (analysis: SchemaAnalysis): number => {
  let score = 0.5; // Base score

  // Boost confidence for common patterns
  if (analysis.hasCreatedAt) score += 0.2;
  if (analysis.hasUpdatedAt) score += 0.1;
  if (analysis.hasStatus) score += 0.1;
  if (analysis.suggestedRequiredFields.length > 0) score += 0.1;

  // Reduce confidence for system tables
  if (analysis.tableName.startsWith('auth_') || 
      analysis.tableName.startsWith('storage_') ||
      analysis.tableName.includes('_internal')) {
    score -= 0.3;
  }

  return Math.min(1, Math.max(0, score));
};

/**
 * Generates suggested custom columns based on table structure
 */
const generateCustomColumns = (analysis: SchemaAnalysis) => {
  const columns = [];

  // Add name column if exists
  if (analysis.columns.some(col => col.name === 'name' || col.name === 'title')) {
    columns.push({
      key: 'name',
      header: 'Name',
      type: 'text' as const
    });
  }

  // Add status column if exists
  if (analysis.hasStatus) {
    columns.push({
      key: 'status',
      header: 'Status',
      type: 'status' as const
    });
  }

  // Add created_at if exists
  if (analysis.hasCreatedAt) {
    columns.push({
      key: 'created_at',
      header: 'Created',
      type: 'date' as const
    });
  }

  return columns;
};

/**
 * Converts snake_case to PascalCase
 */
const toPascalCase = (str: string): string => {
  return str
    .split('_')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
    .join('');
};

/**
 * Generates boilerplate hook code
 */
export const generateHookCode = (config: AutoModuleConfig): string => {
  return `/**
 * Auto-generated hook for ${config.moduleName}
 * Generated from table: ${config.tableName}
 * Confidence: ${(config.confidence * 100).toFixed(0)}%
 */

import { useTypeSafeModuleTemplate } from '@/templates/hooks/useTypeSafeModuleTemplate';
import { ModuleConfig } from '@/utils/moduleValidation';

const ${config.moduleName.toLowerCase()}Config: ModuleConfig = {
  tableName: '${config.tableName}',
  moduleName: '${config.moduleName}',
  requiredFields: [${config.requiredFields.map(f => `'${f}'`).join(', ')}],
  optionalFields: [${config.optionalFields?.map(f => `'${f}'`).join(', ') || ''}],
};

export const use${config.moduleName} = () => {
  return useTypeSafeModuleTemplate(${config.moduleName.toLowerCase()}Config);
};
`;
};

/**
 * Generates boilerplate component code
 */
export const generateComponentCode = (config: AutoModuleConfig): string => {
  const customColumns = config.suggestedCustomColumns || [];
  
  return `/**
 * Auto-generated component for ${config.moduleName}
 * Generated from table: ${config.tableName}
 * Confidence: ${(config.confidence * 100).toFixed(0)}%
 */

import React from 'react';
import { ExtensibleModuleTemplate } from '@/templates/components/ExtensibleModuleTemplate';
import { use${config.moduleName} } from '@/hooks/use${config.moduleName}';
import { StatusBadge } from '@/components/shared/StatusBadge';

export const ${config.moduleName}Module = () => {
  const { items, isLoading, createItem, updateItem } = use${config.moduleName}();

  const customColumns = [
    ${customColumns.map(col => `{
      key: '${col.key}',
      header: '${col.header}',
      render: (item: any) => ${generateColumnRender(col)}
    }`).join(',\n    ')}
  ];

  return (
    <ExtensibleModuleTemplate
      config={{
        tableName: '${config.tableName}',
        moduleName: '${config.moduleName}',
        requiredFields: [${config.requiredFields.map(f => `'${f}'`).join(', ')}]
      }}
      data={items}
      isLoading={isLoading}
      customColumns={customColumns}
      onAdd={() => {
        // TODO: Implement add functionality
        console.log('Add new ${config.moduleName.toLowerCase()}');
      }}
      onEdit={(item) => {
        // TODO: Implement edit functionality
        console.log('Edit ${config.moduleName.toLowerCase()}:', item);
      }}
    />
  );
};
`;
};

/**
 * Generates column render code based on column type
 */
const generateColumnRender = (column: { key: string; type: string }): string => {
  switch (column.type) {
    case 'status':
      return `<StatusBadge status={item.${column.key}} />`;
    case 'date':
      return `item.${column.key} ? new Date(item.${column.key}).toLocaleDateString() : 'N/A'`;
    case 'boolean':
      return `item.${column.key} ? 'Yes' : 'No'`;
    default:
      return `<span className="font-medium">{item.${column.key} || 'N/A'}</span>`;
  }
};
