
/**
 * API Key Monitor Hook - Automatically triggers framework orchestration when API keys are entered
 */

import { useEffect } from 'react';
import { useQuery } from '@tanstack/react-query';
import { supabase } from '@/integrations/supabase/client';
import { useApiConsumptionTrigger } from './useApiConsumptionTrigger';
import { useToast } from './use-toast';

interface ApiKeyWithIntegration {
  id: string;
  name: string;
  type: 'development' | 'production' | 'sandbox';
  created_at: string;
  // Check if this key has been processed for auto-integration
  integration_processed?: boolean;
}

export const useApiKeyMonitor = () => {
  const { toast } = useToast();
  const { triggerManualOrchestration } = useApiConsumptionTrigger();

  // Monitor for new API keys
  const { data: apiKeys, refetch } = useQuery({
    queryKey: ['api-keys-monitor'],
    queryFn: async () => {
      const { data, error } = await supabase
        .from('api_keys')
        .select('*')
        .order('created_at', { ascending: false });

      if (error) throw error;
      return data as ApiKeyWithIntegration[];
    },
    refetchInterval: 10000, // Check every 10 seconds for new keys
    refetchIntervalInBackground: true
  });

  // Auto-trigger orchestration for new API keys
  useEffect(() => {
    if (!apiKeys) return;

    const processNewApiKeys = async () => {
      // Find API keys created in the last minute that haven't been processed
      const oneMinuteAgo = new Date(Date.now() - 60000).toISOString();
      const newApiKeys = apiKeys.filter(key => 
        key.created_at > oneMinuteAgo && !key.integration_processed
      );

      for (const apiKey of newApiKeys) {
        console.log(`üîë New API key detected: ${apiKey.name} (${apiKey.type})`);
        
        try {
          // Automatically trigger the orchestration for this API key
          await triggerAutoIntegrationForApiKey(apiKey);
          
          // Mark as processed (in a real implementation, you'd update the database)
          console.log(`‚úÖ Auto-integration triggered for API key: ${apiKey.name}`);
          
          toast({
            title: "Auto-Integration Activated",
            description: `Framework automatically activated for API key "${apiKey.name}". Generating schemas, RLS policies, and documentation.`,
          });
        } catch (error) {
          console.error(`‚ùå Failed to trigger auto-integration for ${apiKey.name}:`, error);
          toast({
            title: "Auto-Integration Warning",
            description: `Could not automatically activate framework for "${apiKey.name}". Manual activation available.`,
            variant: "destructive"
          });
        }
      }
    };

    processNewApiKeys();
  }, [apiKeys, triggerManualOrchestration, toast]);

  const triggerAutoIntegrationForApiKey = async (apiKey: ApiKeyWithIntegration) => {
    // Determine API type based on key name and type
    const apiType = determineApiType(apiKey.name, apiKey.type);
    
    // Create a synthetic API ID for the orchestration
    const syntheticApiId = `api-key-${apiKey.id}`;
    
    // Trigger the orchestration with comprehensive configuration
    await triggerManualOrchestration({
      apiId: syntheticApiId,
      internalApiId: apiKey.id,
      autoGenerateSchema: true,
      autoGenerateRLS: true,
      autoGenerateDocumentation: true,
      autoGenerateDataMappings: true,
      autoRegisterModules: true,
      generateTypeScriptTypes: true,
      syncWithKnowledgeBase: true
    });

    // Also register the API in the external API registry
    await registerApiKeyAsExternalApi(apiKey, apiType);
  };

  const determineApiType = (keyName: string, keyType: string): 'internal' | 'external' | 'consumed' => {
    const name = keyName.toLowerCase();
    
    // Internal APIs - generated by our system
    if (name.includes('internal') || keyType === 'production' && name.includes('system')) {
      return 'internal';
    }
    
    // External APIs - published for others to consume
    if (name.includes('external') || name.includes('public') || name.includes('marketplace')) {
      return 'external';
    }
    
    // Consumed APIs - third-party APIs we're consuming
    return 'consumed';
  };

  const registerApiKeyAsExternalApi = async (apiKey: ApiKeyWithIntegration, apiType: 'internal' | 'external' | 'consumed') => {
    try {
      const { data, error } = await supabase
        .from('external_api_registry')
        .insert({
          internal_api_id: apiKey.id,
          external_name: `${apiKey.name} API`,
          external_description: `Auto-generated API integration for ${apiKey.name} (${apiType})`,
          version: '1.0.0',
          status: 'draft',
          visibility: apiType === 'internal' ? 'private' : 'public',
          pricing_model: 'free',
          category: 'healthcare',
          tags: ['auto-generated', apiType, apiKey.type],
          authentication_methods: ['api_key'],
          rate_limits: {
            requests: apiKey.type === 'production' ? 10000 : 1000,
            period: 'hour'
          }
        })
        .select()
        .single();

      if (error) throw error;
      
      console.log(`üìù Registered API key as ${apiType} API:`, data);
      return data;
    } catch (error) {
      console.error('Failed to register API key as external API:', error);
      throw error;
    }
  };

  return {
    apiKeys,
    refetch,
    triggerAutoIntegrationForApiKey
  };
};
