
import { useState, useEffect } from 'react';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { supabase } from '@/integrations/supabase/client';
import { useAuthContext } from '@/components/auth/CleanAuthProvider';
import { useToast } from '@/hooks/use-toast';

interface Module {
  id: string;
  moduleName: string;
  description: string;
  version: string;
  lastUpdated: string;
  dependencies: string[];
  status: 'active' | 'inactive' | 'beta';
  isCoreModule: boolean;
  isAutoGenerated: boolean;
  tableName: string | null;
  componentPath: string | null;
}

export const useModules = () => {
  const { user, userRoles } = useAuthContext();
  const { toast } = useToast();
  const queryClient = useQueryClient();
  const [userModules, setUserModules] = useState<Module[]>([]);
  const [isLoadingUserModules, setIsLoadingUserModules] = useState(true);
  const [errorUserModules, setErrorUserModules] = useState<string | null>(null);

  const { data: modules, isLoading: isLoadingAllModules, error: errorAllModules } = useQuery({
    queryKey: ['modules'],
    queryFn: async () => {
      const { data, error } = await supabase
        .from('modules')
        .select('*');

      if (error) {
        console.error('Error fetching modules:', error);
        throw new Error(error.message);
      }
      return data || [];
    },
    retry: 2,
  });

  // Create module mutation
  const createModuleMutation = useMutation({
    mutationFn: async (moduleData: { name: string; description?: string; is_active?: boolean }) => {
      const { data, error } = await supabase
        .from('modules')
        .insert([moduleData])
        .select()
        .single();

      if (error) throw error;
      return data;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['modules'] });
      toast({ title: "Success", description: "Module created successfully!" });
    },
    onError: (error: any) => {
      toast({ title: "Error", description: error.message, variant: "destructive" });
    },
  });

  // Assign module to user mutation
  const assignModuleMutation = useMutation({
    mutationFn: async ({ userId, moduleId, expiresAt }: { userId: string; moduleId: string; expiresAt?: string | null }) => {
      const { data, error } = await supabase
        .from('user_module_assignments')
        .insert([{
          user_id: userId,
          module_id: moduleId,
          expires_at: expiresAt || null,
          assigned_by: user?.id
        }])
        .select()
        .single();

      if (error) throw error;
      return data;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['modules'] });
      toast({ title: "Success", description: "Module assigned successfully!" });
    },
    onError: (error: any) => {
      toast({ title: "Error", description: error.message, variant: "destructive" });
    },
  });

  // Assign module to role mutation
  const assignModuleToRoleMutation = useMutation({
    mutationFn: async ({ roleId, moduleId }: { roleId: string; moduleId: string }) => {
      const { data, error } = await supabase
        .from('role_module_assignments')
        .insert([{
          role_id: roleId,
          module_id: moduleId,
          assigned_by: user?.id
        }])
        .select()
        .single();

      if (error) throw error;
      return data;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['modules'] });
      toast({ title: "Success", description: "Module assigned to role successfully!" });
    },
    onError: (error: any) => {
      toast({ title: "Error", description: error.message, variant: "destructive" });
    },
  });

  useEffect(() => {
    const fetchUserModules = async () => {
      setIsLoadingUserModules(true);
      try {
        if (!user) {
          setErrorUserModules('User not authenticated');
          setUserModules([]);
          return;
        }

        // Fetch user roles from the profiles table
        const { data: profileData, error: profileError } = await supabase
          .from('profiles')
          .select('*')
          .eq('id', user.id)
          .single();
    
        if (profileError) {
          console.error('Error fetching user profile:', profileError);
          setErrorUserModules(profileError.message);
          setUserModules([]);
          return;
        }
    
        // For now, return modules mapped to the expected interface
        const mappedModules = modules?.map(module => ({
          id: module.id,
          moduleName: module.name,
          description: module.description || '',
          version: '1.0.0',
          lastUpdated: module.updated_at,
          dependencies: [],
          status: module.is_active ? 'active' as const : 'inactive' as const,
          isCoreModule: false,
          isAutoGenerated: false,
          tableName: null,
          componentPath: null
        })) || [];
    
        setUserModules(mappedModules);
      } catch (error: any) {
        console.error('Error fetching user modules:', error);
        setErrorUserModules(error.message);
        setUserModules([]);
      } finally {
        setIsLoadingUserModules(false);
      }
    };

    fetchUserModules();
  }, [user, modules]);

  const hasModuleAccess = (moduleName: string): boolean => {
    return userModules.some(module => module.moduleName === moduleName);
  };

  return {
    modules,
    userModules,
    hasModuleAccess,
    isLoadingAllModules,
    isLoadingUserModules,
    isLoadingModules: isLoadingAllModules,
    errorAllModules,
    errorUserModules,
    error: errorAllModules,
    isLoading: isLoadingAllModules,
    createModule: createModuleMutation.mutate,
    isCreating: createModuleMutation.isPending,
    assignModule: assignModuleMutation.mutate,
    isAssigning: assignModuleMutation.isPending,
    assignModuleToRole: assignModuleToRoleMutation.mutate,
    isAssigningToRole: assignModuleToRoleMutation.isPending,
  };
};
