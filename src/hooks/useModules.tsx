import { useState, useEffect } from 'react';
import { useQuery } from '@tanstack/react-query';
import { supabase } from '@/integrations/supabase/client';
import { useAuthContext } from '@/components/auth/CleanAuthProvider';

interface Module {
  id: string;
  moduleName: string;
  description: string;
  version: string;
  lastUpdated: string;
  dependencies: string[];
  status: 'active' | 'inactive' | 'beta';
  isCoreModule: boolean;
  isAutoGenerated: boolean;
  tableName: string | null;
  componentPath: string | null;
}

export const useModules = () => {
  const { user, userRoles } = useAuthContext();
  const [userModules, setUserModules] = useState<Module[]>([]);
  const [isLoadingUserModules, setIsLoadingUserModules] = useState(true);
  const [errorUserModules, setErrorUserModules] = useState<string | null>(null);

  const { data: modules, isLoading: isLoadingAllModules, error: errorAllModules } = useQuery({
    queryKey: ['modules'],
    queryFn: async () => {
      const { data, error } = await supabase
        .from('modules')
        .select('*');

      if (error) {
        console.error('Error fetching modules:', error);
        throw new Error(error.message);
      }
      return data || [];
    },
    retry: 2,
  });

  useEffect(() => {
    const fetchUserModules = async () => {
      setIsLoadingUserModules(true);
      try {
        if (!user) {
          setErrorUserModules('User not authenticated');
          setUserModules([]);
          return;
        }

        // Fetch user roles from the profiles table
        const { data: profileData, error: profileError } = await supabase
          .from('profiles')
          .select('roles')
          .eq('id', user.id)
          .single();
    
        if (profileError) {
          console.error('Error fetching user roles:', profileError);
          setErrorUserModules(profileError.message);
          setUserModules([]);
          return;
        }
    
        const userRoles = profileData?.roles || [];
    
        // Fetch permissions for each role
        let allPermissions = [];
        for (const role of userRoles) {
          const { data: rolePermissions, error: rolePermissionsError } = await supabase
            .from('role_permissions')
            .select('permissions')
            .eq('role_id', role);
    
          if (rolePermissionsError) {
            console.error(`Error fetching permissions for role ${role}:`, rolePermissionsError);
            continue; // Skip to the next role if there's an error
          }
    
          if (rolePermissions && rolePermissions.length > 0) {
            // Assuming 'permissions' is an array within each row
            const permissionsForRole = rolePermissions.flatMap(item => item.permissions);
            allPermissions = [...allPermissions, ...permissionsForRole];
          }
        }
    
        // Deduplicate permissions
        const uniquePermissions = [...new Set(allPermissions)];
    
        // Fetch modules associated with the permissions
        const modulePromises = uniquePermissions.map(async (permission) => {
          const { data: permissionModules, error: permissionModulesError } = await supabase
            .from('permission_modules')
            .select('module_id')
            .eq('permission_id', permission);
    
          if (permissionModulesError) {
            console.error(`Error fetching modules for permission ${permission}:`, permissionModulesError);
            return []; // Return an empty array if there's an error
          }
    
          return permissionModules.map(item => item.module_id);
        });
    
        // Resolve all promises and flatten the array
        const moduleIds = (await Promise.all(modulePromises)).flat();
    
        // Deduplicate module IDs
        const uniqueModuleIds = [...new Set(moduleIds)];
    
        // Fetch module details based on the module IDs
        const { data: userModulesData, error: userModulesError } = await supabase
          .from('modules')
          .select('*')
          .in('id', uniqueModuleIds);
    
        if (userModulesError) {
          console.error('Error fetching module details:', userModulesError);
          setErrorUserModules(userModulesError.message);
          setUserModules([]);
          return;
        }
    
        setUserModules(userModulesData || []);
      } catch (error: any) {
        console.error('Error fetching user modules:', error);
        setErrorUserModules(error.message);
        setUserModules([]);
      } finally {
        setIsLoadingUserModules(false);
      }
    };

    fetchUserModules();
  }, [user, modules]);

  const hasModuleAccess = (moduleName: string): boolean => {
    return userModules.some(module => module.moduleName === moduleName);
  };

  return {
    modules,
    userModules,
    hasModuleAccess,
    isLoadingAllModules,
    isLoadingUserModules,
    errorAllModules,
    errorUserModules
  };
};
