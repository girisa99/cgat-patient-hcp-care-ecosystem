
/**
 * API Consumption Trigger Hook - Automatically triggers orchestration
 */

import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { apiConsumptionOrchestrator } from '@/utils/api/ApiConsumptionOrchestrator';
import { useToast } from '@/hooks/use-toast';
import type { ApiConsumptionConfig, ApiConsumptionResult } from '@/utils/api/ApiConsumptionOrchestrator';

export const useApiConsumptionTrigger = () => {
  const { toast } = useToast();
  const queryClient = useQueryClient();

  // Monitor API consumption and auto-trigger orchestration
  const {
    data: orchestrationResults,
    isLoading: isOrchestrating,
    error: orchestrationError
  } = useQuery({
    queryKey: ['api-consumption-orchestration'],
    queryFn: async () => {
      // Get list of APIs that need orchestration
      const apisNeedingOrchestration = await getApisNeedingOrchestration();
      const results: ApiConsumptionResult[] = [];

      for (const apiId of apisNeedingOrchestration) {
        console.log(`ðŸ”„ Auto-triggering orchestration for API: ${apiId}`);
        
        const config: ApiConsumptionConfig = {
          apiId,
          autoGenerateSchema: true,
          autoGenerateRLS: true,
          autoGenerateDocumentation: true,
          autoGenerateDataMappings: true,
          autoRegisterModules: true,
          generateTypeScriptTypes: true,
          syncWithKnowledgeBase: true
        };

        const result = await apiConsumptionOrchestrator.orchestrateApiConsumption(config);
        results.push(result);

        if (result.success) {
          console.log(`âœ… Auto-orchestration completed for API: ${apiId}`);
          toast({
            title: "API Integration Automated",
            description: `Successfully auto-configured API integration with ${result.registeredModules.length} modules, ${result.generatedRLSPolicies.length} policies, and ${result.generatedDataMappings.length} mappings.`,
          });
        } else {
          console.error(`âŒ Auto-orchestration failed for API: ${apiId}`, result.errors);
          toast({
            title: "Auto-Integration Warning", 
            description: `Some components failed to auto-generate for API integration. ${result.errors.length} errors, ${result.warnings.length} warnings.`,
            variant: "destructive"
          });
        }
      }

      return results;
    },
    refetchInterval: 30000, // Check every 30 seconds for new APIs needing orchestration
    refetchIntervalInBackground: true,
    enabled: true
  });

  // Manual trigger for specific API
  const manualOrchestrationMutation = useMutation({
    mutationFn: async (config: ApiConsumptionConfig) => {
      console.log('ðŸŽ¯ Manual orchestration triggered for:', config.apiId);
      return await apiConsumptionOrchestrator.orchestrateApiConsumption(config);
    },
    onSuccess: (result) => {
      if (result.success) {
        toast({
          title: "Manual Integration Complete",
          description: `Successfully configured API integration with comprehensive automation.`,
        });
        queryClient.invalidateQueries({ queryKey: ['api-consumption-orchestration'] });
      } else {
        toast({
          title: "Integration Issues",
          description: `Integration completed with ${result.errors.length} errors and ${result.warnings.length} warnings.`,
          variant: "destructive"
        });
      }
    },
    onError: (error) => {
      console.error('Manual orchestration failed:', error);
      toast({
        title: "Integration Failed",
        description: "Failed to complete API integration orchestration.",
        variant: "destructive"
      });
    }
  });

  return {
    orchestrationResults,
    isOrchestrating,
    orchestrationError,
    triggerManualOrchestration: manualOrchestrationMutation.mutate,
    isManualTriggering: manualOrchestrationMutation.isPending
  };
};

// Helper function to identify APIs that need orchestration
async function getApisNeedingOrchestration(): Promise<string[]> {
  // This would typically check for:
  // 1. New external APIs without complete integration
  // 2. APIs with missing schemas, RLS policies, or documentation
  // 3. APIs that need module registration
  // 4. APIs with outdated TypeScript types
  
  // For now, return empty array - in real implementation this would query the database
  return [];
}
