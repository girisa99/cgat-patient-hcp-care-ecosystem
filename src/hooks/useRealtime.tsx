
/**
 * Universal Real-time Hook with Component/Service Tracking
 * Automatically integrates with any module for real-time updates including RBAC components
 */

import { useEffect, useCallback } from 'react';
import { useQueryClient } from '@tanstack/react-query';
import { realtimeManager } from '@/utils/realtime';
import { moduleRegistry } from '@/utils/moduleRegistry';
import { RealtimeEvent } from '@/utils/realtime';
import { useToast } from '@/hooks/use-toast';

export interface UseRealtimeOptions {
  tableName: string;
  moduleName?: string;
  enableNotifications?: boolean;
  customInvalidation?: string[];
  onEvent?: (event: RealtimeEvent) => void;
  trackComponents?: boolean;
}

export const useRealtime = (options: UseRealtimeOptions) => {
  const queryClient = useQueryClient();
  const { toast } = useToast();

  const handleRealtimeEvent = useCallback((event: RealtimeEvent) => {
    console.log(`📡 Real-time event received for ${options.tableName}:`, event.eventType);
    
    // Auto-invalidate queries - enhanced for modules and components
    const queryKeysToInvalidate = [
      options.tableName,
      `${options.tableName}-list`,
      `${options.tableName}-search`,
      ...(options.customInvalidation || [])
    ];

    // Special handling for module changes
    if (options.tableName === 'modules') {
      queryKeysToInvalidate.push(
        'modules',
        'user-effective-modules',
        'module-components',
        'module-permissions',
        'rbac-data'
      );
      
      // Update module registry with real-time changes
      if (event.eventType === 'INSERT' && event.payload?.new) {
        const newModule = event.payload.new;
        console.log('🔄 Auto-registering new module from real-time:', newModule.name);
        
        // This would typically trigger component detection
        setTimeout(() => {
          moduleRegistry.register({
            moduleName: newModule.name,
            tableName: options.tableName,
            requiredFields: ['name'],
            optionalFields: ['description'],
            version: '1.0.0',
            lastUpdated: new Date().toISOString(),
            dependencies: [],
            status: 'active',
            isAutoGenerated: true,
            description: newModule.description || 'Auto-detected module'
          });
        }, 1000);
      }
    }

    // Special handling for user role changes
    if (options.tableName === 'user_roles') {
      queryKeysToInvalidate.push(
        'users',
        'users-all',
        'consistent-users',
        'unified-user-data',
        'user-statistics',
        'user-effective-modules',
        'rbac-permissions'
      );
    }

    // Special handling for role changes
    if (options.tableName === 'roles') {
      queryKeysToInvalidate.push(
        'users',
        'user-roles',
        'permissions',
        'role-module-assignments'
      );
    }

    // Special handling for module assignments
    if (options.tableName === 'user_module_assignments' || options.tableName === 'role_module_assignments') {
      queryKeysToInvalidate.push(
        'user-effective-modules',
        'module-permissions',
        'rbac-assignments'
      );
    }

    queryKeysToInvalidate.forEach(key => {
      queryClient.invalidateQueries({ queryKey: [key] });
    });

    // Show notifications if enabled
    if (options.enableNotifications) {
      const moduleName = options.moduleName || options.tableName;
      let message = '';
      
      switch (event.eventType) {
        case 'INSERT':
          if (options.tableName === 'user_roles') {
            message = 'User role assigned successfully';
          } else if (options.tableName === 'modules') {
            message = `New module "${event.payload?.new?.name}" detected and registered`;
          } else {
            message = `New ${moduleName.toLowerCase()} added`;
          }
          break;
        case 'UPDATE':
          if (options.tableName === 'modules') {
            message = `Module "${event.payload?.new?.name}" updated - checking for component changes`;
          } else {
            message = `${moduleName} updated`;
          }
          break;
        case 'DELETE':
          if (options.tableName === 'user_roles') {
            message = 'User role removed successfully';
          } else if (options.tableName === 'modules') {
            message = `Module removed from registry`;
          } else {
            message = `${moduleName} removed`;
          }
          break;
        case 'BULK_OPERATION':
          message = `Bulk operation completed for ${moduleName.toLowerCase()}`;
          break;
      }

      if (message) {
        toast({
          title: "Real-time Update",
          description: message,
          duration: 3000,
        });
      }
    }

    // Trigger component/service detection for module changes
    if (options.trackComponents && options.tableName === 'modules' && event.eventType === 'INSERT') {
      console.log('🔍 Triggering component detection for new module...');
      // This would trigger the ApiChangeDetector to scan for components
      setTimeout(async () => {
        try {
          const { ApiChangeDetector } = await import('@/utils/automation/ApiChangeDetector');
          await ApiChangeDetector.detectAndNotifyChanges();
        } catch (error) {
          console.error('Failed to trigger API change detection:', error);
        }
      }, 2000);
    }

    // Call custom event handler
    if (options.onEvent) {
      options.onEvent(event);
    }
  }, [options, queryClient, toast]);

  useEffect(() => {
    const unsubscribe = realtimeManager.subscribe(options.tableName, handleRealtimeEvent);
    
    return unsubscribe;
  }, [options.tableName, handleRealtimeEvent]);

  // Listen for global invalidation events
  useEffect(() => {
    const handleGlobalInvalidation = (event: CustomEvent) => {
      const { queryKeys, tableName } = event.detail;
      
      if (tableName === options.tableName || queryKeys.includes(options.tableName)) {
        queryKeys.forEach((key: string) => {
          queryClient.invalidateQueries({ queryKey: [key] });
        });
      }
    };

    window.addEventListener('realtime-invalidate', handleGlobalInvalidation);
    
    return () => {
      window.removeEventListener('realtime-invalidate', handleGlobalInvalidation);
    };
  }, [options.tableName, queryClient]);
};

/**
 * Hook for auto-detecting and applying real-time to any module with component tracking
 */
export const useAutoRealtime = (tableName: string, trackComponents: boolean = true) => {
  useEffect(() => {
    // Auto-register this module if not already registered
    const registeredModules = realtimeManager.getRegisteredModules();
    const moduleName = tableName
      .split('_')
      .map(word => word.charAt(0).toUpperCase() + word.slice(1))
      .join('');

    if (!registeredModules.includes(moduleName)) {
      realtimeManager.registerModule({
        tableName,
        moduleName,
        enableInsert: true,
        enableUpdate: true,
        enableDelete: true,
        enableBulkOperations: true
      });
    }
  }, [tableName]);

  return useRealtime({
    tableName,
    enableNotifications: true,
    trackComponents
  });
};

/**
 * Enhanced hook specifically for module management with RBAC tracking
 */
export const useModuleRealtime = () => {
  return useRealtime({
    tableName: 'modules',
    moduleName: 'Modules',
    enableNotifications: true,
    trackComponents: true,
    customInvalidation: [
      'user-effective-modules',
      'module-permissions',
      'rbac-assignments',
      'module-components'
    ],
    onEvent: (event) => {
      console.log('📋 Module real-time event:', event);
      
      // Log module registry stats
      const stats = moduleRegistry.getStats();
      console.log('📊 Module registry stats:', stats);
    }
  });
};
